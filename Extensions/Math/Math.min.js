(function () {
	function T(a, c, e, d) {
		var b = [];
		if (void 0 === d ? 0 : d) for (; c >= a; c -= e) b.push(c);
		else for (; a <= c; a += e) b.push(a);
		return b;
	}
	function z(a, c) {
		c = void 0 === c ? {} : c;
		for (var e = 0, d = Object.keys(a); e < d.length; e++) {
			var b = d[e],
				f = a[b][1];
			if (
				("number" === f && isNaN(c[b])) ||
				("array" === f && !Array.isArray(c[b])) ||
				void 0 === c[b] ||
				null === c[b]
			)
				c[b] = a[b][0];
		}
		return c;
	}
	function U(a, c) {
		Object.defineProperty(window, a, {
			configurable: !0,
			enumerable: !0,
			get: c,
			set: function (e) {
				Object.defineProperty(window, a, {
					configurable: !0,
					enumerable: !0,
					value: e,
					writable: !0,
				});
			},
		});
	}
	for (
		var P = {
				CENTERX: function () {
					return window.C.workingContext.width / 2;
				},
				CENTERY: function () {
					return window.C.workingContext.height / 2;
				},
			},
			Q = Object.keys(P),
			M = 0;
		M < Q.length;
		M++
	) {
		var R = Q[M];
		U(R, P[R]);
	}
	var A = {
		init_Canvas: function () {
			background(0);
			fill(WHITE);
			stroke(WHITE);
			noStroke();
			strokeWidth(2);
			translate(CENTERX, CENTERY);
			scale(1, -1);
			window.C.workingContext.yAxisInverted = !0;
			fontSize(20);
		},
		clear: function (a, c, e, d) {
			var b = window.C.workingContext;
			a = a || -b.width / 2;
			c = c || -b.height / 2;
			e = e || 2 * b.width;
			d = d || 2 * b.height;
			b.clearRect(a, c, e, d);
		},
		scale: function (a, c) {
			window.C.workingContext.scale(a, void 0 === c ? a : c);
		},
		text: function (a, c, e, d) {
			var b = window.C.workingContext;
			b.yAxisInverted
				? (scale(1, -1),
				  b.doFill ? b.fillText(a, c, -e, d) : b.doStroke && b.strokeText(a, c, -e, d),
				  scale(1, -1))
				: b.doFill
				? b.fillText(a, c, e, d)
				: b.doStroke && b.strokeText(a, c, e, d);
		},
		arrow: function (a, c, e, d, b, f) {
			b = void 0 === b ? 10 : b;
			f = void 0 === f ? 0.7 : f;
			var g = Math.atan2(d - c, e - a);
			A.arrowHead(e, d, b, g, f);
			f = Math.atan(f / 2);
			var m = Math.sin(g) * b * Math.cos(f);
			e -= Math.cos(g) * b * Math.cos(f);
			line(a, c, e, d - m);
		},
		axes: function (a) {
			a = void 0 === a ? {} : a;
			var c = window.C.workingContext,
				e = {
					length: [c.height, "number"],
					rotation: [Math.PI / 2, "number"],
					textRotation: [-Math.PI / 2, "number"],
					includeNumbers: [!1],
					includeTicks: [!1],
					includeLeftTip: [!0],
					includeRightTip: [!0],
				};
			c = z(
				{
					length: [c.width, "number"],
					includeNumbers: [!1],
					includeTicks: [!1],
					includeLeftTip: [!0],
					includeRightTip: [!0],
					textDirection: [-0.3, -1],
				},
				a.xAxis,
			);
			e = z(e, a.yAxis);
			a = a.center || [0, 0];
			var d = c.range || [-8, 8, 1],
				b = e.range || [-8, 8, 1];
			d = c.length / 2 + (d[0] / d[2]) * (c.length / ((d[1] - d[0]) / d[2]));
			b = e.length / 2 + (b[0] / b[2]) * (e.length / ((b[1] - b[0]) / b[2]));
			translate(a[0], a[1]);
			translate(d, 0);
			c = numberLine(c);
			translate(-d, b);
			e = numberLine(e);
			d = [c.unitLength, e.unitLength];
			translate(-a[0], -a[1] - b);
			return { unit: d, xAxis: c, yAxis: e };
		},
		arrowHead: function (a, c, e, d, b) {
			e = void 0 === e ? 10 : e;
			d = void 0 === d ? 0 : d;
			var f = window.C.workingContext;
			b = Math.atan((void 0 === b ? 2 : b) / 2);
			f.beginPath();
			f.moveTo(a, c);
			f.lineTo(a - e * Math.cos(d - b), c - e * Math.sin(d - b));
			f.lineTo(a - e * Math.cos(d + b), c - e * Math.sin(d + b));
			f.lineTo(a, c);
			f.doFill ? f.fill() : f.stroke();
		},
		doubleArrow: function (a, c, e, d, b, f) {
			b = void 0 === b ? 10 : b;
			f = void 0 === f ? 0.6 : f;
			var g = Math.atan(f / 2),
				m = Math.atan2(d - c, e - a),
				y = Math.cos(m) * b * Math.cos(g);
			g = Math.sin(m) * b * Math.cos(g);
			A.arrowHead(a, c, b, Math.PI + m, f);
			A.arrow(a + y, c + g, e, d, b, f);
		},
		numberLine: function (a) {
			function c() {
				stroke(t);
				strokeWidth(F);
				for (
					var v = u ? B.length - 1 : B.length, l = w ? 1 : 0;
					l < v && 0 > g.indexOf(B[0][l]);
					l++
				) {
					var x = B[l];
					if (0 !== Number(x) || !D) {
						var q = p;
						-1 < y.indexOf(x) && (q *= J);
						line(G * l, -q / 2, G * l, q / 2);
					}
				}
			}
			function e() {
				var v = 0 < m.length ? m : B;
				fill(a.textColor);
				fontSize(h);
				for (
					var l = (-h / 3) * Math.cos(n) + H[1] * h,
						x = u ? v.length - 1 : v.length,
						q = w ? 1 : 0;
					q < x && 0 > g.indexOf(v[q]);
					q++
				) {
					var N = v[q].toFixed(I);
					if (0 !== Number(N) || !D) {
						var O = measureText(N).width,
							S = (-O / 2) * Math.cos(n) + H[0] * h + (h / 2) * Math.sin(n);
						translate(G * q + S, l - O * Math.sin(n));
						rotate(n);
						text(N, 0, 0);
						rotate(-n);
						translate(-(G * q + S), -(l - O * Math.sin(n)));
					}
				}
			}
			a = void 0 === a ? {} : a;
			z(
				{
					length: [window.C.workingContext.width, "number"],
					rotation: [0],
					center: [[0, 0]],
					range: [[-8, 8, 1], "array"],
					numbersToExclude: [[]],
					labelsToInclude: [[]],
					numbersWithElongatedTicks: [[]],
					includeLeftTip: [!1],
					includeRightTip: [!1],
					includeNumbers: [!0],
					tipWidth: [20, "number"],
					tipSizeRatio: [1, "number"],
					color: [GREY],
					lineWidth: [3, "number"],
					includeTicks: [!0],
					excludeOriginTick: [!1],
					longerTickMultiple: [1.5, "number"],
					tickHeight: [15, "number"],
					textDirection: [[-0.3, -1]],
					textColor: [WHITE],
					textSize: [17, "number"],
					textRotation: [0],
				},
				a,
			);
			var d = a.length,
				b = a.rotation,
				f = a.center,
				g = a.numbersToExclude,
				m = a.labelsToInclude,
				y = a.numbersWithElongatedTicks,
				w = a.includeLeftTip,
				u = a.includeRightTip,
				r = a.tipWidth,
				E = a.tipSizeRatio,
				t = a.color,
				F = a.lineWidth,
				D = a.excludeOriginTick,
				J = a.longerTickMultiple,
				p = a.tickHeight,
				H = a.textDirection,
				h = a.textSize,
				n = a.textRotation,
				I = a.decimalPlaces,
				k = a.range;
			Array.isArray(k) && 2 === k.length && (k = [k[0], k[1], 1]);
			isNaN(I) && (I = (k[2].toString().split(".")[1] || []).length || 0);
			var K = k[0],
				L = k[1];
			k = k[2];
			var G = d / ((L - K) / k),
				B = T(K, L, k);
			translate(f[0], f[1]);
			rotate(b);
			translate(-d / 2, 0);
			a.includeTicks && c();
			a.includeNumbers && e();
			translate(d / 2, 0);
			(function () {
				stroke(t);
				strokeWidth(F);
				fill(t);
				var v = Math.atan(E / 2),
					l = -d / 2,
					x = d / 2;
				w && (A.arrowHead(l, 0, r, Math.PI, E), (l += r * Math.cos(v)));
				u && (A.arrowHead(x, 0, r, 0, E), (x -= r * Math.cos(v)));
				line(l, 0, x, 0);
			})();
			rotate(-b);
			translate(-f[0], -f[1]);
			return { unitLength: G, tickList: B };
		},
		numberPlane: function (a) {
			a = void 0 === a ? {} : a;
			var c = window.C.workingContext,
				e = {
					textDirection: [[0, 0.8]],
					length: [c.height, "number"],
					textRotation: [-Math.PI / 2, "number"],
					excludeOriginTick: [!0],
					includeLeftTip: [!1],
					includeRightTip: [!1],
					includeNumbers: [!0],
					includeTicks: [!0],
				},
				d = {
					lineWidth: [1, "number"],
					color: [BLUE_C + "a0"],
					subgrids: [1, "number"],
					subgridLineColor: [GREY + "50"],
					subgridLineWidth: [0.7, "number"],
				};
			c = z(
				{
					textDirection: [[0, -1.1]],
					length: [c.width, "number"],
					excludeOriginTick: [!0],
					includeLeftTip: [!1],
					includeRightTip: [!1],
					includeNumbers: [!0],
					includeTicks: [!0],
				},
				a.xAxis,
			);
			e = z(e, a.yAxis);
			var b = z(d, a.grid),
				f = b.subgrids;
			a = a.center || [0, 0];
			d = c.range || [-8, 8, 1];
			var g = e.range || [-8, 8, 1],
				m = (d[1] - d[0]) / d[2],
				y = (g[1] - g[0]) / g[2],
				w = c.length / m,
				u = e.length / y,
				r = (d[0] / d[2]) * w,
				E = (d[1] / d[2]) * w,
				t = (g[0] / g[2]) * u,
				F = (g[1] / g[2]) * u;
			d = c.length / 2 + r;
			g = e.length / 2 + t;
			var D = [w / f, u / f];
			translate(a[0] + d, a[1]);
			(function () {
				function J(I, k, K, L) {
					strokeWidth(b.subgridLineWidth);
					stroke(b.subgridLineColor);
					line(I, k, K, L);
				}
				translate(r, 0);
				for (var p = D[0], H = D[1], h = 0; h <= m; h++) {
					translate(h * w, 0);
					strokeWidth(b.lineWidth);
					stroke(b.color);
					line(0, t, 0, F);
					for (var n = 1; n <= f && h < m; n++) J(n * p, t, n * p, F);
					translate(-h * w);
				}
				translate(-r, t);
				for (p = 0; p <= y; p++) {
					translate(0, p * u);
					strokeWidth(b.lineWidth);
					stroke(b.color);
					line(r, 0, E, 0);
					for (h = 1; h <= f && p < y; h++) J(r, h * H, E, h * H);
					translate(0, -p * u);
				}
				translate(0, -t);
			})();
			c = axes({ xAxis: c, yAxis: e });
			e = c.unit;
			translate(-(a[0] + d), -a[1] - g);
			return { unit: e, subgridUnit: D, xAxis: c.xAxis, yAxis: c.yAxis };
		},
	};
	window.C.addExtension(A);
})();
