<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: image/processing.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: image/processing.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/** @module Image Processing */
import { readColor } from "../color/color_reader.js";
import { C } from "../main.js";

/**
 * returns color at a given point from ImageData
 *
 * @param {ImageData} pixels
 * @param {number} x x-coordinate of point
 * @param {number} y y-coordinate of point
 * @return {Uint8ClampedArray} array of color components [r, g, b, a]
 */
export function getPixelColor(pixels, x, y) {
	let index = pixels.width * y + x;
	return pixels.data.subarray(index, index + 4);
}

/**
 * Convert image data to 2d array of colors.
 *
 * @param {ImageData} pixels
 * @returns {Array&lt;Array&lt;number>>} 2d array of colors
 */
export function imageDataToColorArray(pixels) {
	let w = pixels.width,
		h = pixels.height,
		dat = Array.from(pixels.data),
		image2D = [];
	for (var y = 0; y &lt; h; y++) {
		image2D.push([]);
		for (var x = 0; x &lt; w; x++) {
			let i = h * y + x,
				r = dat[i],
				g = dat[i + 1],
				b = dat[i + 2],
				a = dat[i + 3];
			image2D[y].push([r, g, b, a]);
		}
	}
	return image2D;
}

/**
 * Returns if neighbor pixels have the same color as given.
 *
 * @param {Array&lt;number>} color color to compare with
 * @param {ImageData} pixels image data
 * @param {number} x x-coordinate of point
 * @param {number} y y-coordinate of point
 * @return {boolean}
 */
export function hasNeighbourColor(color, pixels, x, y) {
	let dat = pixels.data,
		w = pixels.width;
	for (let i = x - 1; i &lt;= x + 1; i++) {
		for (let j = y - 1; j &lt;= y + 1; j++) {
			if (i !== x || j !== y) {
				let index = w * y + x,
					neighbourColor = dat.subarray(index, index + 4);
				if (
					neighbourColor[0] === color[0] &amp;&amp;
					neighbourColor[1] === color[1] &amp;&amp;
					neighbourColor[2] === color[2] &amp;&amp;
					neighbourColor[3] === color[3]
				) {
					return true;
				}
			}
		}
	}
	return false;
}

// TODO: Under construction
//function createMapOfLetter(letter) {
//	let img = Image.new("RGB", (230, 230), "white"),
//		d = ImageDraw.Draw(img),
//		font = ImageFont.truetype("arial.ttf", 300);
//	d.text((15, -50), letter, (fill = (0, 0, 0)), (font = font));
//
//	let pixels = img.load(),
//		ans = [];
//
//	for (let x = 0; x &lt; 230; x++) {
//		for (let y = 0; y &lt; 230; y++) {
//			if (pixels[(x, y)] == (0, 0, 0)) {
//				if (
//					hasNeighbourColor((255, 255, 255), pixels, x, y) &amp;&amp;
//					!hasNeighbourColor((255, 0, 0), pixels, x, y)
//				) {
//					pixels[(x, y)] = (255, 0, 0);
//					ans.append([x, y]);
//				}
//			}
//		}
//	}
//
//	return ans;
//}

/**
 * Replaces a color by another color in given image.
 * @param {ImageData} image image to be processed
 * @param {*} toReplace color to be replaced
 * @param {*} replaced replaced color
 * @param {boolean} [matchAlpha = false] whether to check if alpha channel is same as that of toReplace.
 * @param {number} [tolerance = 0] minimum difference between each color channel
 */
export function replaceColorInImage(
	image,
	toReplace,
	replaced,
	matchAlpha = false,
	tolerance = 0,
) {
	let data = image.data,
		newData = C.workingContext.createImageData(image.width, image.height);
	const [r1, g1, b1, a1] = readColor(toReplace).rgbaA;
	const [r2, g2, b2, a2] = readColor(replaced).rgbaA;
	let nonOccurances = 0;
	for (let i = 0; i &lt; data.length; i += 4) {
		let r = data[i],
			g = data[i + 1],
			b = data[i + 2],
			a = data[i + 3];
		if (
			Math.abs(r - r1) &lt;= tolerance &amp;&amp;
			Math.abs(g - g1) &lt;= tolerance &amp;&amp;
			Math.abs(b - b1) &lt;= tolerance &amp;&amp;
			(matchAlpha ? Math.abs(a - a1) &lt;= tolerance : true)
		) {
			newData.data[i] = r2;
			newData.data[i + 1] = g2;
			newData.data[i + 2] = b2;
			if (matchAlpha) newData.data[i + 3] = a2;
			else newData.data[i + 3] = 255;
		} else {
			newData.data[i] = r;
			newData.data[i + 1] = g;
			newData.data[i + 2] = b;
			if (matchAlpha) newData.data[i + 3] = a;
			else newData.data[i + 3] = 255;
			nonOccurances++;
		}
	}
	console.log(nonOccurances);
	return newData;
}

/**
 * Converts a image to ImageData.
 * @param {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement|ImageBitmap|OffscreenCanvas} image image
 * @param {number} x x-coordinate of starting point in image
 * @param {number} y y-coordinate of starting point in image
 * @param {number} [width = image.width] width of area to be covered
 * @param {number} [height = image.height] height of area to be covered
 * @param {boolean} [smoothen = false] whether to capture a smoothened the image
 */
export function imageToData(image, x, y, width, height, smoothen = false) {
	let cvs = document.createElement("canvas");
	let ctx = cvs.getContext("2d");
	let dpr = C.dpr;
	x = x * dpr || 0;
	y = y * dpr || 0;
	cvs.width = width = (isNaN(width) ? image.width : width) * dpr;
	cvs.height = height = (isNaN(height) ? image.height : height) * dpr;
	ctx.imageSmoothingEnabled = smoothen;
	ctx.drawImage(image, 0, 0, width, height);
	return ctx.getImageData(x, y, width, height);
}
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Modules</h3><ul><li><a href="module-Arithmetic%2520functions.html">Arithmetic functions</a></li><li><a href="module-Arrows.html">Arrows</a></li><li><a href="module-Braces.html">Braces</a></li><li><a href="module-Color%2520Converters.html">Color Converters</a></li><li><a href="module-Color%2520gradient.html">Color gradient</a></li><li><a href="module-Color%2520lear.html">Color lear</a></li><li><a href="module-Color%2520Palettes.html">Color Palettes</a></li><li><a href="module-Color%2520Reader.html">Color Reader</a></li><li><a href="module-Colors.html">Colors</a></li><li><a href="module-Coordinate%2520systems.html">Coordinate systems</a></li><li><a href="module-Extra%2520shapes.html">Extra shapes</a></li><li><a href="module-Geometric%2520shapes.html">Geometric shapes</a></li><li><a href="module-Image.html">Image</a></li><li><a href="module-Image%2520Processing.html">Image Processing</a></li><li><a href="module-Plottter%2520Functions.html">Plottter Functions</a></li><li><a href="module-Point%2520Utils.html">Point Utils</a></li><li><a href="module-Random%2520Colors.html">Random Colors</a></li><li><a href="module-Random%2520functions.html">Random functions</a></li><li><a href="module-Settings.html">Settings</a></li><li><a href="module-Tex.html">Tex</a></li><li><a href="module-text.html">text</a></li><li><a href="module-Utils.html">Utils</a></li></ul><h3>Classes</h3><ul><li><a href="m4_m4.html">m4</a></li><li><a href="WebGL.html">WebGL</a></li></ul><h3>Global</h3><ul><li><a href="global.html#C">C</a></li><li><a href="global.html#createWebGL">createWebGL</a></li><li><a href="global.html#fontStretch">fontStretch</a></li><li><a href="global.html#generatePointsInArc">generatePointsInArc</a></li><li><a href="global.html#quadraticCurve">quadraticCurve</a></li><li><a href="global.html#readMatrix">readMatrix</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 3.6.11</a> on Tue Aug 08 2023 22:55:31 GMT+0530 (India Standard Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
